/*
<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
<<<<<<< HEAD
=======
=======
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
>>>>>>> 25da024d9b6316e99e1931459ffa9a6f3d5c90eb
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
 */

/*
 * RandomRBF.java
<<<<<<< HEAD
 * Copyright (C) 2005-2012 University of Waikato, Hamilton, New Zealand
=======
<<<<<<< HEAD
 * Copyright (C) 2005-2012 University of Waikato, Hamilton, New Zealand
=======
 * Copyright (C) 2005 University of Waikato, Hamilton, New Zealand
>>>>>>> 25da024d9b6316e99e1931459ffa9a6f3d5c90eb
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
 *
 */

package weka.datagenerators.classifiers.classification;

<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Random;
import java.util.Vector;

import weka.core.Attribute;
import weka.core.DenseInstance;
<<<<<<< HEAD
=======
=======
import weka.core.Attribute;
import weka.core.FastVector;
>>>>>>> 25da024d9b6316e99e1931459ffa9a6f3d5c90eb
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
import weka.core.Instance;
import weka.core.Instances;
import weka.core.Option;
import weka.core.RevisionUtils;
import weka.core.Utils;
import weka.datagenerators.ClassificationGenerator;

<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
/**
 * <!-- globalinfo-start --> RandomRBF data is generated by first creating a
 * random set of centers for each class. Each center is randomly assigned a
 * weight, a central point per attribute, and a standard deviation. To generate
 * new instances, a center is chosen at random taking the weights of each center
 * into consideration. Attribute values are randomly generated and offset from
 * the center, where the overall vector has been scaled so that its length
 * equals a value sampled randomly from the Gaussian distribution of the center.
 * The particular center chosen determines the class of the instance.<br/>
 * RandomRBF data contains only numeric attributes as it is non-trivial to
 * include nominal values.
 * <p/>
 * <!-- globalinfo-end -->
 * 
 * <!-- options-start --> Valid options are:
 * <p/>
 * 
 * <pre>
 * -h
 *  Prints this help.
 * </pre>
 * 
 * <pre>
 * -o &lt;file&gt;
 *  The name of the output file, otherwise the generated data is
 *  printed to stdout.
 * </pre>
 * 
 * <pre>
 * -r &lt;name&gt;
 *  The name of the relation.
 * </pre>
 * 
 * <pre>
 * -d
 *  Whether to print debug informations.
 * </pre>
 * 
 * <pre>
 * -S
 *  The seed for random function (default 1)
 * </pre>
 * 
 * <pre>
 * -n &lt;num&gt;
 *  The number of examples to generate (default 100)
 * </pre>
 * 
 * <pre>
 * -a &lt;num&gt;
 *  The number of attributes (default 10).
 * </pre>
 * 
 * <pre>
 * -c &lt;num&gt;
 *  The number of classes (default 2)
 * </pre>
 * 
 * <pre>
 * -C &lt;num&gt;
 *  The number of centroids to use. (default 50)
 * </pre>
 * 
 * <!-- options-end -->
 * 
 * @author Richard Kirkby (rkirkby at cs dot waikato dot ac dot nz)
 * @author FracPete (fracpete at waikato dot ac dot nz)
 * @version $Revision: 10203 $
 */

public class RandomRBF extends ClassificationGenerator {

  /** for serialization */
  static final long serialVersionUID = 6069033710635728720L;

<<<<<<< HEAD
=======
=======
import java.util.Enumeration;
import java.util.Random;
import java.util.Vector;

/**
 <!-- globalinfo-start -->
 * RandomRBF data is generated by first creating a random set of centers for each class. Each center is randomly assigned a weight, a central point per attribute, and a standard deviation. To generate new instances, a center is chosen at random taking the weights of each center into consideration. Attribute values are randomly generated and offset from the center, where the overall vector has been scaled so that its length equals a value sampled randomly from the Gaussian distribution of the center. The particular center chosen determines the class of the instance.<br/>
 *  RandomRBF data contains only numeric attributes as it is non-trivial to include nominal values.
 * <p/>
 <!-- globalinfo-end -->
 *
 <!-- options-start -->
 * Valid options are: <p/>
 * 
 * <pre> -h
 *  Prints this help.</pre>
 * 
 * <pre> -o &lt;file&gt;
 *  The name of the output file, otherwise the generated data is
 *  printed to stdout.</pre>
 * 
 * <pre> -r &lt;name&gt;
 *  The name of the relation.</pre>
 * 
 * <pre> -d
 *  Whether to print debug informations.</pre>
 * 
 * <pre> -S
 *  The seed for random function (default 1)</pre>
 * 
 * <pre> -n &lt;num&gt;
 *  The number of examples to generate (default 100)</pre>
 * 
 * <pre> -a &lt;num&gt;
 *  The number of attributes (default 10).</pre>
 * 
 * <pre> -c &lt;num&gt;
 *  The number of classes (default 2)</pre>
 * 
 * <pre> -C &lt;num&gt;
 *  The number of centroids to use. (default 50)</pre>
 * 
 <!-- options-end -->
 *
 * @author Richard Kirkby (rkirkby at cs dot waikato dot ac dot nz)
 * @author FracPete (fracpete at waikato dot ac dot nz)
 * @version $Revision: 1.4 $
 */

public class RandomRBF
  extends ClassificationGenerator {

  /** for serialization */
  static final long serialVersionUID = 6069033710635728720L;  
  
>>>>>>> 25da024d9b6316e99e1931459ffa9a6f3d5c90eb
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
  /** Number of attribute the dataset should have */
  protected int m_NumAttributes;

  /** Number of Classes the dataset should have */
  protected int m_NumClasses;

  /** the number of centroids to use for generation */
  protected int m_NumCentroids;
<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb

  /** the centroids */
  protected double[][] m_centroids;

  /** the classes of the centroids */
  protected int[] m_centroidClasses;

  /** the weights of the centroids */
  protected double[] m_centroidWeights;

<<<<<<< HEAD
=======
=======
  
  /** the centroids */
  protected double[][] m_centroids;
  
  /** the classes of the centroids */
  protected int[] m_centroidClasses;
  
  /** the weights of the centroids */
  protected double[] m_centroidWeights;
  
>>>>>>> 25da024d9b6316e99e1931459ffa9a6f3d5c90eb
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
  /** the stddevs of the centroids */
  protected double[] m_centroidStdDevs;

  /**
   * initializes the generator with default values
   */
  public RandomRBF() {
    super();

    setNumAttributes(defaultNumAttributes());
    setNumClasses(defaultNumClasses());
    setNumCentroids(defaultNumCentroids());
  }

  /**
   * Returns a string describing this data generator.
<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
   * 
   * @return a description of the data generator suitable for displaying in the
   *         explorer/experimenter gui
   */
  public String globalInfo() {
    return "RandomRBF data is generated by first creating a random set of "
<<<<<<< HEAD
=======
=======
   *
   * @return a description of the data generator suitable for
   * displaying in the explorer/experimenter gui
   */
  public String globalInfo() {
    return 
        "RandomRBF data is generated by first creating a random set of "
>>>>>>> 25da024d9b6316e99e1931459ffa9a6f3d5c90eb
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
      + "centers for each class. Each center is randomly assigned a weight, "
      + "a central point per attribute, and a standard deviation. To "
      + "generate new instances, a center is chosen at random taking the "
      + "weights of each center into consideration. Attribute values are "
      + "randomly generated and offset from the center, where the overall "
      + "vector has been scaled so that its length equals a value sampled "
      + "randomly from the Gaussian distribution of the center. The "
      + "particular center chosen determines the class of the instance.\n "
      + "RandomRBF data contains only numeric attributes as it is "
      + "non-trivial to include nominal values.";
  }

<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
  /**
   * Returns an enumeration describing the available options.
   * 
   * @return an enumeration of all the available options
   */
  @Override
  public Enumeration<Option> listOptions() {
    Vector<Option> result = enumToVector(super.listOptions());

    result.addElement(new Option("\tThe number of attributes (default "
      + defaultNumAttributes() + ").", "a", 1, "-a <num>"));

    result.addElement(new Option("\tThe number of classes (default "
      + defaultNumClasses() + ")", "c", 1, "-c <num>"));

    result.add(new Option("\tThe number of centroids to use. (default "
      + defaultNumCentroids() + ")", "C", 1, "-C <num>"));
<<<<<<< HEAD
=======
=======
 /**
   * Returns an enumeration describing the available options.
   *
   * @return an enumeration of all the available options
   */
  public Enumeration listOptions() {
    Vector result = enumToVector(super.listOptions());

    result.addElement(new Option(
          "\tThe number of attributes (default " 
          + defaultNumAttributes() + ").",
          "a", 1, "-a <num>"));

    result.addElement(new Option(
        "\tThe number of classes (default " + defaultNumClasses() + ")",
        "c", 1, "-c <num>"));

    result.add(new Option(
              "\tThe number of centroids to use. (default " 
              + defaultNumCentroids() + ")",
              "C", 1, "-C <num>"));
>>>>>>> 25da024d9b6316e99e1931459ffa9a6f3d5c90eb
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb

    return result.elements();
  }

  /**
<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
   * Parses a list of options for this object.
   * <p/>
   * 
   * <!-- options-start --> Valid options are:
   * <p/>
   * 
   * <pre>
   * -h
   *  Prints this help.
   * </pre>
   * 
   * <pre>
   * -o &lt;file&gt;
   *  The name of the output file, otherwise the generated data is
   *  printed to stdout.
   * </pre>
   * 
   * <pre>
   * -r &lt;name&gt;
   *  The name of the relation.
   * </pre>
   * 
   * <pre>
   * -d
   *  Whether to print debug informations.
   * </pre>
   * 
   * <pre>
   * -S
   *  The seed for random function (default 1)
   * </pre>
   * 
   * <pre>
   * -n &lt;num&gt;
   *  The number of examples to generate (default 100)
   * </pre>
   * 
   * <pre>
   * -a &lt;num&gt;
   *  The number of attributes (default 10).
   * </pre>
   * 
   * <pre>
   * -c &lt;num&gt;
   *  The number of classes (default 2)
   * </pre>
   * 
   * <pre>
   * -C &lt;num&gt;
   *  The number of centroids to use. (default 50)
   * </pre>
   * 
   * <!-- options-end -->
   * 
   * @param options the list of options as an array of strings
   * @throws Exception if an option is not supported
   */
  @Override
  public void setOptions(String[] options) throws Exception {
    String tmpStr;
<<<<<<< HEAD
=======
=======
   * Parses a list of options for this object. <p/>
   *
   <!-- options-start -->
   * Valid options are: <p/>
   * 
   * <pre> -h
   *  Prints this help.</pre>
   * 
   * <pre> -o &lt;file&gt;
   *  The name of the output file, otherwise the generated data is
   *  printed to stdout.</pre>
   * 
   * <pre> -r &lt;name&gt;
   *  The name of the relation.</pre>
   * 
   * <pre> -d
   *  Whether to print debug informations.</pre>
   * 
   * <pre> -S
   *  The seed for random function (default 1)</pre>
   * 
   * <pre> -n &lt;num&gt;
   *  The number of examples to generate (default 100)</pre>
   * 
   * <pre> -a &lt;num&gt;
   *  The number of attributes (default 10).</pre>
   * 
   * <pre> -c &lt;num&gt;
   *  The number of classes (default 2)</pre>
   * 
   * <pre> -C &lt;num&gt;
   *  The number of centroids to use. (default 50)</pre>
   * 
   <!-- options-end -->
   *
   * @param options the list of options as an array of strings
   * @throws Exception if an option is not supported
   */
  public void setOptions(String[] options) throws Exception {
    String        tmpStr;
>>>>>>> 25da024d9b6316e99e1931459ffa9a6f3d5c90eb
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb

    super.setOptions(options);

    tmpStr = Utils.getOption('a', options);
<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
    if (tmpStr.length() != 0) {
      setNumAttributes(Integer.parseInt(tmpStr));
    } else {
      setNumAttributes(defaultNumAttributes());
    }

    tmpStr = Utils.getOption('c', options);
    if (tmpStr.length() != 0) {
      setNumClasses(Integer.parseInt(tmpStr));
    } else {
      setNumClasses(defaultNumClasses());
    }

    tmpStr = Utils.getOption('C', options);
    if (tmpStr.length() != 0) {
      setNumCentroids(Integer.parseInt(tmpStr));
    } else {
      setNumCentroids(defaultNumCentroids());
    }
<<<<<<< HEAD
=======
=======
    if (tmpStr.length() != 0)
      setNumAttributes(Integer.parseInt(tmpStr));
    else
      setNumAttributes(defaultNumAttributes());

    tmpStr = Utils.getOption('c', options);
    if (tmpStr.length() != 0)
      setNumClasses(Integer.parseInt(tmpStr));
    else
      setNumClasses(defaultNumClasses());
    
    tmpStr = Utils.getOption('C', options);
    if (tmpStr.length() != 0)
      setNumCentroids(Integer.parseInt(tmpStr));
    else
      setNumCentroids(defaultNumCentroids());
>>>>>>> 25da024d9b6316e99e1931459ffa9a6f3d5c90eb
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
  }

  /**
   * Gets the current settings of the datagenerator.
<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
   * 
   * @return an array of strings suitable for passing to setOptions
   */
  @Override
  public String[] getOptions() {
    Vector<String> result;
    String[] options;
    int i;

    result = new Vector<String>();
    options = super.getOptions();
    for (i = 0; i < options.length; i++) {
      result.add(options[i]);
    }

<<<<<<< HEAD
=======
=======
   *
   * @return an array of strings suitable for passing to setOptions
   */
  public String[] getOptions() {
    Vector        result;
    String[]      options;
    int           i;
    
    result  = new Vector();
    options = super.getOptions();
    for (i = 0; i < options.length; i++)
      result.add(options[i]);
    
>>>>>>> 25da024d9b6316e99e1931459ffa9a6f3d5c90eb
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
    result.add("-a");
    result.add("" + getNumAttributes());

    result.add("-c");
    result.add("" + getNumClasses());

    result.add("-C");
    result.add("" + getNumCentroids());
<<<<<<< HEAD

    return result.toArray(new String[result.size()]);
=======
<<<<<<< HEAD

    return result.toArray(new String[result.size()]);
=======
    
    return (String[]) result.toArray(new String[result.size()]);
>>>>>>> 25da024d9b6316e99e1931459ffa9a6f3d5c90eb
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
  }

  /**
   * returns the default number of attributes
   * 
   * @return the default number of attributes
   */
  protected int defaultNumAttributes() {
    return 10;
  }

  /**
   * Sets the number of attributes the dataset should have.
<<<<<<< HEAD
   * 
=======
<<<<<<< HEAD
   * 
=======
>>>>>>> 25da024d9b6316e99e1931459ffa9a6f3d5c90eb
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
   * @param numAttributes the new number of attributes
   */
  public void setNumAttributes(int numAttributes) {
    m_NumAttributes = numAttributes;
  }

  /**
   * Gets the number of attributes that should be produced.
<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
   * 
   * @return the number of attributes that should be produced
   */
  public int getNumAttributes() {
    return m_NumAttributes;
  }

  /**
   * Returns the tip text for this property
   * 
   * @return tip text for this property suitable for displaying in the
   *         explorer/experimenter gui
<<<<<<< HEAD
=======
=======
   * @return the number of attributes that should be produced
   */
  public int getNumAttributes() { 
    return m_NumAttributes; 
  }
  
  /**
   * Returns the tip text for this property
   * 
   * @return tip text for this property suitable for
   *         displaying in the explorer/experimenter gui
>>>>>>> 25da024d9b6316e99e1931459ffa9a6f3d5c90eb
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
   */
  public String numAttributesTipText() {
    return "The number of attributes the generated data will contain.";
  }

  /**
   * returns the default number of classes
   * 
   * @return the default number of classes
   */
  protected int defaultNumClasses() {
    return 2;
  }

  /**
   * Sets the number of classes the dataset should have.
<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
   * 
   * @param numClasses the new number of classes
   */
  public void setNumClasses(int numClasses) {
    m_NumClasses = numClasses;
<<<<<<< HEAD
=======
=======
   * @param numClasses the new number of classes
   */
  public void setNumClasses(int numClasses) { 
    m_NumClasses = numClasses; 
>>>>>>> 25da024d9b6316e99e1931459ffa9a6f3d5c90eb
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
  }

  /**
   * Gets the number of classes the dataset should have.
<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
   * 
   * @return the number of classes the dataset should have
   */
  public int getNumClasses() {
    return m_NumClasses;
  }

  /**
   * Returns the tip text for this property
   * 
   * @return tip text for this property suitable for displaying in the
   *         explorer/experimenter gui
<<<<<<< HEAD
=======
=======
   * @return the number of classes the dataset should have
   */
  public int getNumClasses() { 
    return m_NumClasses; 
  }
  
  /**
   * Returns the tip text for this property
   * 
   * @return tip text for this property suitable for
   *         displaying in the explorer/experimenter gui
>>>>>>> 25da024d9b6316e99e1931459ffa9a6f3d5c90eb
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
   */
  public String numClassesTipText() {
    return "The number of classes to generate.";
  }

  /**
   * returns the default number of centroids
   * 
   * @return the default number of centroids
   */
  protected int defaultNumCentroids() {
    return 50;
  }
<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb

  /**
   * Gets the number of centroids.
   * 
   * @return the number of centroids.
   */
  public int getNumCentroids() {
    return m_NumCentroids;
  }

  /**
   * Sets the number of centroids to use.
   * 
   * @param value the number of centroids to use.
   */
  public void setNumCentroids(int value) {
    if (value > 0) {
      m_NumCentroids = value;
    } else {
      System.out.println("At least 1 centroid is necessary (provided: " + value
        + ")!");
    }
  }

  /**
   * Returns the tip text for this property
   * 
   * @return tip text for this property suitable for displaying in the
   *         explorer/experimenter gui
<<<<<<< HEAD
=======
=======
  
  /**
   * Gets the number of centroids.
   *
   * @return the number of centroids.
   */
  public int getNumCentroids() { 
    return m_NumCentroids; 
  }
  
  /**
   * Sets the number of centroids to use.
   *
   * @param value the number of centroids to use.
   */
  public void setNumCentroids(int value) { 
    if (value > 0)
      m_NumCentroids = value; 
    else
      System.out.println("At least 1 centroid is necessary (provided: " 
          + value + ")!");
  }  
  
  /**
   * Returns the tip text for this property
   * 
   * @return tip text for this property suitable for
   *         displaying in the explorer/experimenter gui
>>>>>>> 25da024d9b6316e99e1931459ffa9a6f3d5c90eb
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
   */
  public String numCentroidsTipText() {
    return "The number of centroids to use.";
  }

  /**
<<<<<<< HEAD
   * Return if single mode is set for the given data generator mode depends on
   * option setting and or generator type.
=======
<<<<<<< HEAD
   * Return if single mode is set for the given data generator mode depends on
   * option setting and or generator type.
=======
   * Return if single mode is set for the given data generator
   * mode depends on option setting and or generator type.
>>>>>>> 25da024d9b6316e99e1931459ffa9a6f3d5c90eb
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
   * 
   * @return single mode flag
   * @throws Exception if mode is not set yet
   */
<<<<<<< HEAD
  @Override
=======
<<<<<<< HEAD
  @Override
=======
>>>>>>> 25da024d9b6316e99e1931459ffa9a6f3d5c90eb
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
  public boolean getSingleModeFlag() throws Exception {
    return true;
  }

  /**
   * returns a random index based on the given proportions
<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
   * 
   * @param proportionArray the proportions
   * @param random the random number generator to use
   * @return the random index
   */
  protected int chooseRandomIndexBasedOnProportions(double[] proportionArray,
    Random random) {

    double probSum;
    double val;
    int index;
    double sum;

    probSum = Utils.sum(proportionArray);
    val = random.nextDouble() * probSum;
    index = 0;
    sum = 0.0;

    while ((sum <= val) && (index < proportionArray.length)) {
      sum += proportionArray[index++];
    }

<<<<<<< HEAD
=======
=======
   *
   * @param proportionArray     the proportions
   * @param random              the random number generator to use
   * @return the random index
   */
  protected int chooseRandomIndexBasedOnProportions(
      double[] proportionArray, Random random) {

    double      probSum;
    double      val;
    int         index;
    double      sum;

    probSum = Utils.sum(proportionArray);
    val     = random.nextDouble() * probSum;
    index   = 0;
    sum     = 0.0;
    
    while ((sum <= val) && (index < proportionArray.length))
      sum += proportionArray[index++];
    
>>>>>>> 25da024d9b6316e99e1931459ffa9a6f3d5c90eb
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
    return index - 1;
  }

  /**
<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
   * Initializes the format for the dataset produced. Must be called before the
   * generateExample or generateExamples methods are used. Re-initializes the
   * random number generator with the given seed.
   * 
   * @return the format for the dataset
   * @throws Exception if the generating of the format failed
   * @see #getSeed()
   */
  @Override
  public Instances defineDataFormat() throws Exception {
    int i;
    int j;
    ArrayList<Attribute> atts;
    ArrayList<String> clsValues;
    Random rand;

    m_Random = new Random(getSeed());
    rand = getRandom();
<<<<<<< HEAD
=======
=======
   * Initializes the format for the dataset produced. 
   * Must be called before the generateExample or generateExamples
   * methods are used.
   * Re-initializes the random number generator with the given seed.
   *
   * @return the format for the dataset 
   * @throws Exception if the generating of the format failed
   * @see  #getSeed()
   */
  public Instances defineDataFormat() throws Exception {
    int             i;
    int             j;
    FastVector      atts;
    FastVector      clsValues;
    Random          rand;

    m_Random = new Random(getSeed());
    rand     = getRandom();
>>>>>>> 25da024d9b6316e99e1931459ffa9a6f3d5c90eb
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb

    // number of examples is the same as given per option
    setNumExamplesAct(getNumExamples());

    // initialize centroids
<<<<<<< HEAD
    m_centroids = new double[getNumCentroids()][getNumAttributes()];
=======
<<<<<<< HEAD
    m_centroids = new double[getNumCentroids()][getNumAttributes()];
=======
    m_centroids       = new double[getNumCentroids()][getNumAttributes()];
>>>>>>> 25da024d9b6316e99e1931459ffa9a6f3d5c90eb
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
    m_centroidClasses = new int[getNumCentroids()];
    m_centroidWeights = new double[getNumCentroids()];
    m_centroidStdDevs = new double[getNumCentroids()];

    for (i = 0; i < getNumCentroids(); i++) {
<<<<<<< HEAD
      for (j = 0; j < getNumAttributes(); j++) {
        m_centroids[i][j] = rand.nextDouble();
      }
=======
<<<<<<< HEAD
      for (j = 0; j < getNumAttributes(); j++) {
        m_centroids[i][j] = rand.nextDouble();
      }
=======
      for (j = 0; j < getNumAttributes(); j++)
        m_centroids[i][j] = rand.nextDouble();
>>>>>>> 25da024d9b6316e99e1931459ffa9a6f3d5c90eb
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
      m_centroidClasses[i] = rand.nextInt(getNumClasses());
      m_centroidWeights[i] = rand.nextDouble();
      m_centroidStdDevs[i] = rand.nextDouble();
    }

    // initialize dataset format
<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
    atts = new ArrayList<Attribute>();
    for (i = 0; i < getNumAttributes(); i++) {
      atts.add(new Attribute("a" + i));
    }

    clsValues = new ArrayList<String>();
    for (i = 0; i < getNumClasses(); i++) {
      clsValues.add("c" + i);
    }
    atts.add(new Attribute("class", clsValues));

    m_DatasetFormat = new Instances(getRelationNameToUse(), atts, 0);

<<<<<<< HEAD
=======
=======
    atts = new FastVector();
    for (i = 0; i < getNumAttributes(); i++)
      atts.addElement(new Attribute("a" + i));

    clsValues = new FastVector();
    for (i = 0; i < getNumClasses(); i++)
      clsValues.addElement("c" + i);
    atts.addElement(new Attribute("class", clsValues));
    
    m_DatasetFormat = new Instances(getRelationNameToUse(), atts, 0);
    
>>>>>>> 25da024d9b6316e99e1931459ffa9a6f3d5c90eb
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
    return m_DatasetFormat;
  }

  /**
<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
   * Generates one example of the dataset.
   * 
   * @return the generated example
   * @throws Exception if the format of the dataset is not yet defined
   * @throws Exception if the generator only works with generateExamples which
   *           means in non single mode
   */
  @Override
  public Instance generateExample() throws Exception {
    Instance result;
    int centroid;
    double[] atts;
    double magnitude;
    double desiredMag;
    double scale;
    int i;
    double label;
    Random rand;

    result = null;
    rand = getRandom();

    if (m_DatasetFormat == null) {
      throw new Exception("Dataset format not defined.");
    }

    // generate class label based on class probs
    centroid = chooseRandomIndexBasedOnProportions(m_centroidWeights, rand);
    label = m_centroidClasses[centroid];

    // generate attributes
    atts = new double[getNumAttributes() + 1];
    for (i = 0; i < getNumAttributes(); i++) {
      atts[i] = (rand.nextDouble() * 2.0) - 1.0;
    }
    atts[atts.length - 1] = label;

    magnitude = 0.0;
    for (i = 0; i < getNumAttributes(); i++) {
      magnitude += atts[i] * atts[i];
    }

    magnitude = Math.sqrt(magnitude);
    desiredMag = rand.nextGaussian() * m_centroidStdDevs[centroid];
    scale = desiredMag / magnitude;
    for (i = 0; i < getNumAttributes(); i++) {
      atts[i] *= scale;
      atts[i] += m_centroids[centroid][i];
      result = new DenseInstance(1.0, atts);
<<<<<<< HEAD
=======
=======
   * Generates one example of the dataset. 
   *
   * @return the generated example
   * @throws Exception if the format of the dataset is not yet defined
   * @throws Exception if the generator only works with generateExamples
   * which means in non single mode
   */
  public Instance generateExample() throws Exception {
    Instance    result;
    int         centroid;
    double[]    atts;
    double      magnitude;
    double      desiredMag;
    double      scale;
    int         i;
    double      label;
    Random      rand;

    result = null;
    rand   = getRandom();

    if (m_DatasetFormat == null)
      throw new Exception("Dataset format not defined.");

    // generate class label based on class probs
    centroid = chooseRandomIndexBasedOnProportions(m_centroidWeights, rand);
    label    = m_centroidClasses[centroid];

    // generate attributes
    atts = new double[getNumAttributes() + 1];
    for (i = 0; i < getNumAttributes(); i++)
      atts[i] = (rand.nextDouble() * 2.0) - 1.0;
    atts[atts.length - 1] = label;
    
    magnitude = 0.0;
    for (i = 0; i < getNumAttributes(); i++)
      magnitude += atts[i] * atts[i];
    
    magnitude  = Math.sqrt(magnitude);
    desiredMag = rand.nextGaussian() * m_centroidStdDevs[centroid];
    scale      = desiredMag / magnitude;
    for (i = 0; i < getNumAttributes(); i++) {
      atts[i] *= scale;
      atts[i] += m_centroids[centroid][i];
      result   = new Instance(1.0, atts);
>>>>>>> 25da024d9b6316e99e1931459ffa9a6f3d5c90eb
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
    }

    // dataset reference
    result.setDataset(m_DatasetFormat);
<<<<<<< HEAD

=======
<<<<<<< HEAD

=======
    
>>>>>>> 25da024d9b6316e99e1931459ffa9a6f3d5c90eb
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
    return result;
  }

  /**
   * Generates all examples of the dataset. Re-initializes the random number
   * generator with the given seed, before generating instances.
<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
   * 
   * @return the generated dataset
   * @throws Exception if the format of the dataset is not yet defined
   * @throws Exception if the generator only works with generateExample, which
   *           means in single mode
   * @see #getSeed()
   */
  @Override
  public Instances generateExamples() throws Exception {
    Instances result;
    int i;

    result = new Instances(m_DatasetFormat, 0);
    m_Random = new Random(getSeed());

    for (i = 0; i < getNumExamplesAct(); i++) {
      result.add(generateExample());
    }

<<<<<<< HEAD
=======
=======
   *
   * @return the generated dataset
   * @throws Exception if the format of the dataset is not yet defined
   * @throws Exception if the generator only works with generateExample,
   * which means in single mode
   * @see   #getSeed()
   */
  public Instances generateExamples() throws Exception {
    Instances       result;
    int             i;

    result   = new Instances(m_DatasetFormat, 0);
    m_Random = new Random(getSeed());

    for (i = 0; i < getNumExamplesAct(); i++)
      result.add(generateExample());
    
>>>>>>> 25da024d9b6316e99e1931459ffa9a6f3d5c90eb
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
    return result;
  }

  /**
<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
   * Generates a comment string that documentates the data generator. By default
   * this string is added at the beginning of the produced output as ARFF file
   * type, next after the options.
   * 
   * @return string contains info about the generated rules
   */
  @Override
  public String generateStart() {
    StringBuffer result;
    int i;
<<<<<<< HEAD
=======
=======
   * Generates a comment string that documentates the data generator.
   * By default this string is added at the beginning of the produced output
   * as ARFF file type, next after the options.
   * 
   * @return string contains info about the generated rules
   */
  public String generateStart () {
    StringBuffer        result;
    int                 i;
>>>>>>> 25da024d9b6316e99e1931459ffa9a6f3d5c90eb
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb

    result = new StringBuffer();

    result.append("%\n");
    result.append("% centroids:\n");
<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
    for (i = 0; i < getNumCentroids(); i++) {
      result.append("% " + i + ".: " + Utils.arrayToString(m_centroids[i])
        + "\n");
    }
    result.append("%\n");
    result.append("% centroidClasses: "
      + Utils.arrayToString(m_centroidClasses) + "\n");
    result.append("%\n");
    result.append("% centroidWeights: "
      + Utils.arrayToString(m_centroidWeights) + "\n");
    result.append("%\n");
    result.append("% centroidStdDevs: "
      + Utils.arrayToString(m_centroidStdDevs) + "\n");
    result.append("%\n");

<<<<<<< HEAD
=======
=======
    for (i = 0; i < getNumCentroids(); i++)
      result.append(
          "% " + i + ".: " + Utils.arrayToString(m_centroids[i]) + "\n");
    result.append("%\n");
    result.append(
        "% centroidClasses: " + Utils.arrayToString(m_centroidClasses) + "\n");
    result.append("%\n");
    result.append(
        "% centroidWeights: " + Utils.arrayToString(m_centroidWeights) + "\n");
    result.append("%\n");
    result.append(
        "% centroidStdDevs: " + Utils.arrayToString(m_centroidStdDevs) + "\n");
    result.append("%\n");
    
>>>>>>> 25da024d9b6316e99e1931459ffa9a6f3d5c90eb
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
    return result.toString();
  }

  /**
<<<<<<< HEAD
   * Generates a comment string that documentats the data generator. By default
   * this string is added at the end of theproduces output as ARFF file type.
=======
<<<<<<< HEAD
   * Generates a comment string that documentats the data generator. By default
   * this string is added at the end of theproduces output as ARFF file type.
=======
   * Generates a comment string that documentats the data generator.
   * By default this string is added at the end of theproduces output
   * as ARFF file type.
>>>>>>> 25da024d9b6316e99e1931459ffa9a6f3d5c90eb
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
   * 
   * @return string contains info about the generated rules
   * @throws Exception if the generating of the documentaion fails
   */
<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
  @Override
  public String generateFinished() throws Exception {
    return "";
  }

  /**
   * Returns the revision string.
   * 
   * @return the revision
   */
  @Override
  public String getRevision() {
    return RevisionUtils.extract("$Revision: 10203 $");
<<<<<<< HEAD
=======
=======
  public String generateFinished() throws Exception {
    return "";
  }
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
    return RevisionUtils.extract("$Revision: 1.4 $");
>>>>>>> 25da024d9b6316e99e1931459ffa9a6f3d5c90eb
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
  }

  /**
   * Main method for executing this class.
<<<<<<< HEAD
   * 
   * @param args should contain arguments for the data producer:
=======
<<<<<<< HEAD
   * 
   * @param args should contain arguments for the data producer:
=======
   *
   * @param args should contain arguments for the data producer: 
>>>>>>> 25da024d9b6316e99e1931459ffa9a6f3d5c90eb
>>>>>>> ef2ab6295a3053865d54c2bdb992ca1d99d638cb
   */
  public static void main(String[] args) {
    runDataGenerator(new RandomRBF(), args);
  }
}
